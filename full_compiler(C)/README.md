# A simple C-to-MIPS compiler by C



## Reconstruct scanner

Based on the specification, the following changes are made:

- Reconstruct the token
  - Previously, I just passed the token's name (for example, ID, SEMI, ...) into the parser, but now it needs the actual value of the "ID" and the "INT_NUM". 
  - So I record all the characters while scanning the text, and load them into a data structure "token", which contains the following fields:
    - <u>type_name</u>, e.g., ID, SEMI, ...
    - <u>token_value</u>, e.g., "name_of_the_string", "1612", ... (Only valid when type_name == ID or INT_NUM)
    - <u>tr_value</u>, which carries the name of the temporary registers of the "exp" series nonterminal symbols (to be discussed)
    - <u>end_label</u>, which only adapts in the "if_stmt" nonterminal symbols (to be discussed)
    - <u>stringstream ss</u>, which carries the translated MIPS code of that code chunk (to be discussed)
  - Override default copy constructor & assignment operators in class token.



## Reconstruct parser

On the basis of assignment2, generally speaking, I take some actions when executing "reduce" orders.

- Data structure
  - For the saved registers, once created, it will never be recycled. So we use a `<string, int>` hashmap to record the relationship between the name of the tokens and the index of the saved registers.
    - For example, q <-> 25 means the variable named "q" is stored in the 25th saved registers, which is virtual (> 8) and saved in the memory.
  - For the temporary registers, the space can be recycled. So we use a `<int>` hashset to  record the occupation status of each index of temp registers.
    - For example, 5 in existence means, "$t5" is under use.
- Memory management
  - For the virtual registers, i.e., the index of the registers are greater than 8, it means that they are actually stored in the memory. To record the occupation status of the memory space, the `<int, string>` hashmap is used to record the occupation status of each memory position; the `<string, int>` hashmap is used to find the index according to the name of the registers instead.
  - The memory is allocated by creating temp registers / saved registers; 
  - The memory is recycled by discarding temp registers. 
- If-else statement
  - LR(1)'s properties makes it hard to predict the future. It can get conclusions only until the parsing ends.
  - Inspired by the MIPS code generated by Compiler Explorer, with combination to the LR(1) parsing process, I came up with an idea: why not store the generated MIPS code inside the tokens, and passed them during the reduction? Below are the analysis.


> Example code #1
>
> ```c
>  if(a != 0){
>      a = a + 1;
>  }
> ```
>
> Parsing order:
> 1. if_stmt -> IF LPAR exp RPAR code_block   
> 2. if_statement -> if_stmt
>
> Corresponding MIPS code ([Compiler Explorer (godbolt.org)](https://godbolt.org/))
>
> ```assembly
> 		...
> 		lw      $2,8($fp)
>         nop
>         beq     $2,$0,$L2
>         nop
> 
>         lw      $2,8($fp)
>         nop
>         addiu   $2,$2,1
>         sw      $2,8($fp)
> $L2:
> 		...
> ```
>
> As we see, we need to label `$L2` behind the `code_block`. 
>
> Example code #2
>
> ```c
> if(a != 0){
>     a = a + 1;
> }
> else if(b != 0){
>     b = b + 1;
> }
> else{
>     c = c + 1;
> }
> ```
>
> Parsing order:
> 1. if_stmt -> IF LPAR exp RPAR code_block   (First if)
> 2. if_stmt -> IF LPAR exp RPAR code_block   (Second if, i.e., else if)
> 3. if_statement -> if_stmt ELSE code_block. (End of the second if)
> 4. if_statement -> if_stmt ELSE code_block. (End of the first if)
>
> As we can see, on the end of the 1st and 2nd code block, we need to jump out of the whole if- else if - else statement.
>
> Apart from that, when the `exp` inside of the `if()` condition is not satisfied, we need to jump to the next label or the end.
>
> Let's take a closer glance at the code when parsing reduction rules `if_statement -> if_stmt ELSE code_block. (End of the second if)`
>
> ```c
> if(a != 0){
>     a = a + 1;
> }
> else 
> //////// $Label: if the a != 0 is not satisfied, jump here.
> if(b != 0){
>     b = b + 1;
> }
> else{
>     c = c + 1;
> }
> //////// $Label: if the a = a + 1 is done, jump here.
> ```
>
> Okay, things could be clear. when executing reduction rule `if_statement -> if_stmt ELSE code_block. (End of the second if)`, we can first print the info related to `if_Stmt`, then insert the first label, then print the info related to `code_block`, then insert the second label. In this way, we need to store all the generated code inside the tokens and pass within each other.
>
> Example code #3
>
> ```c
> if(a != 0){
>     a = a + 1;
> }
> else{
>     c = c + 1;
> }
> ```
>
> 1. if_stmt -> IF LPAR exp RPAR code_block
> 2. if_statement -> if_stmt ELSE code_block.
>
> Since the parsing just similar to the depth first search, so that we only need to care about the if-else statements on the same layer.



- Arrays

  - Declarations

    - On declarations, we need to allocate some space to each elements of the array, by adding key-value pair to the SR hashmap.
    - The actions are taken implicitly. No MIPS code will be generated.

  - Fetching & Storing inside the statements.

    - We don't store calculation result inside the "exp" series nonterminal tokens (symbols). So how to fetch / store the elements of the array? 
    - Answer: by changing the location of `$sp`
    - We use some temporary variables to calculate the shift amount of the storage address, then use the shift amount based on the `$sp` to fetch / Store the elements of the array.
    - Example:

    > ```c
    > int b = 1;
    > int a[10];
    > 
    > a[b] = 1;
    > ```
    >
    > Parsing process
    >
    > ```assembly
    > # int b = 1
    > li $t0, 1
    > move $t8, $t0
    > sw $t8, 0($sp)
    > 
    > # a[10] -> implicitly, no MIPS code is generated
    > 
    > # a[b] = 1
    > lw $t9, 0($sp)
    > move $t0, $t9		# the value of b is loaded into $t0
    > li $t1, 1			# the value of the constant 1 is loaded into $t1
    > li $t8 4			
    > mul $t8, $t8, $t0	# Multiply b by 4, to satisfy the requirement of shift amount = base + index * 4
    > addi $t9, $sp, 4	# The base address (a[0]) is loaded into $t0
    > add $t8, $t9, $t8	# real address = base + shift amount
    > sw $t1, 0($t8)		# stored the constant into the real address of the array a[b].
    > ```



## Finally...

According to the above analysis and some implementation, I made a simple C -> MIPS code generator.

The code will be printed out to the screen only when it is the reduction rules `program -> xxx` under execution.



## How to run my program

Programming language: C++ => `g++` is needed.

Dockerfile content:

```
FROM ubuntu:18.04

RUN apt-get clean && apt-get update && apt-get install make g++ -y
```

File structure:

```powershell
.
|-- compiler.Dockerfile
|-- compiler-report.pdf
`-- SourceCode
    |-- compiler.h
    |-- makefile
    |-- parser.cpp
    |-- reduce_map.cpp
    |-- run_compiler.sh
    |-- scanner.cpp
    |-- shift_map.cpp
    `-- TestCases
        |-- test1.c
        |-- test2.c
        |-- test3.c
        |-- test4.c
        |-- test5.c
        `-- test6.c
```

⭐︎**IMPORTANT: please put test files under `\TestCases\` folder**.

⭐︎**IMPORTANT: If the terminal shows "bash: ./run_compiler.sh: Permission denied", use `sh run_compiler.sh test1.c ` instead. **

It will take a little bit longer to compiler (~15s). Relax!

```bash
(base) −> docker build -f compiler.Dockerfile -t compiler .
(base) −> docker run -it --privileged=true --mount type=bind,source=/root/Compiler/compiler/SourceCode,target=/opt/compiler_src/ compiler bash
−> cd /opt/compiler_src/
−> make clean
−> make all
−> sh run_compiler.sh test1.c
li $t0, 1
move $t8, $t0
sw $t8, 0($sp)
...
```